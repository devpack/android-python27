// qpainter.sip generated by MetaSIP on Fri Oct 22 13:36:23 2010
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qpainter.h>
%End

class QPainter
{
%TypeHeaderCode
#include <qpainter.h>
%End

%TypeCode
// Return an array on the heap of class instances extracted from a set of
// Python arguments.
template<class TYPE>
static TYPE *qtgui_inst_array(const TYPE *first, PyObject *t, sipTypeDef *td)
{
    TYPE *arr = new TYPE[1 + PyTuple_GET_SIZE(t)];

    arr[0] = *first;

    for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(t); ++i)
    {
        int iserr = 0, state;
        TYPE *itm;

        itm  = reinterpret_cast<TYPE *>(sipForceConvertToType(PyTuple_GET_ITEM(t, i), td, 0, SIP_NOT_NONE, &state, &iserr));

        if (iserr)
        {
            sipReleaseType(itm, td, state);

            PyErr_Format(PyExc_TypeError, "each argument must be an instance of %s", sipTypeAsPyTypeObject(td)->tp_name);

            delete[] arr;
            return 0;
        }

        arr[1 + i] = *itm;

        sipReleaseType(itm, td, state);
    }

    return arr;
}
%End

public:
    enum RenderHint
    {
        Antialiasing,
        TextAntialiasing,
        SmoothPixmapTransform,
%If (Qt_4_3_0 -)
        HighQualityAntialiasing,
%End
%If (Qt_4_4_0 -)
        NonCosmeticDefaultPen,
%End
    };

    typedef QFlags<QPainter::RenderHint> RenderHints;
    QPainter();
    explicit QPainter(QPaintDevice *);
    ~QPainter();
    QPaintDevice *device() const;
    bool begin(QPaintDevice *);
    bool end();
    bool isActive() const;
    void initFrom(const QWidget *);

    enum CompositionMode
    {
        CompositionMode_SourceOver,
        CompositionMode_DestinationOver,
        CompositionMode_Clear,
        CompositionMode_Source,
        CompositionMode_Destination,
        CompositionMode_SourceIn,
        CompositionMode_DestinationIn,
        CompositionMode_SourceOut,
        CompositionMode_DestinationOut,
        CompositionMode_SourceAtop,
        CompositionMode_DestinationAtop,
        CompositionMode_Xor,
%If (Qt_4_3_0 -)
        CompositionMode_Plus,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Multiply,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Screen,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Overlay,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Darken,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Lighten,
%End
%If (Qt_4_3_0 -)
        CompositionMode_ColorDodge,
%End
%If (Qt_4_3_0 -)
        CompositionMode_ColorBurn,
%End
%If (Qt_4_3_0 -)
        CompositionMode_HardLight,
%End
%If (Qt_4_3_0 -)
        CompositionMode_SoftLight,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Difference,
%End
%If (Qt_4_3_0 -)
        CompositionMode_Exclusion,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceOrDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceAndDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceXorDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceAndNotDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceOrNotDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceXorDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSource,
%End
%If (Qt_4_5_0 -)
        RasterOp_NotSourceAndDestination,
%End
%If (Qt_4_5_0 -)
        RasterOp_SourceAndNotDestination,
%End
    };

    void setCompositionMode(QPainter::CompositionMode);
    QPainter::CompositionMode compositionMode() const;
    const QFont &font() const;
    void setFont(const QFont &);
    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;
    void setPen(const QColor &);
    void setPen(const QPen &);
    void setPen(Qt::PenStyle);
    const QPen &pen() const;
    void setBrush(const QBrush &);
    void setBrush(Qt::BrushStyle);
    const QBrush &brush() const;
    void setBackgroundMode(Qt::BGMode);
    Qt::BGMode backgroundMode() const;
    QPoint brushOrigin() const;
    void setBrushOrigin(const QPointF &);
    void setBackground(const QBrush &);
    const QBrush &background() const;
    QRegion clipRegion() const;
    QPainterPath clipPath() const;
    void setClipRect(const QRectF &, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipRegion(const QRegion &, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipPath(const QPainterPath &, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipping(bool);
    bool hasClipping() const;
    void save();
    void restore();
    void setMatrix(const QMatrix &, bool combine = false);
    const QMatrix &matrix() const;
    const QMatrix &deviceMatrix() const;
    void resetMatrix();
    void setMatrixEnabled(bool);
    bool matrixEnabled() const;
    void scale(qreal, qreal);
    void shear(qreal, qreal);
    void rotate(qreal);
    void translate(const QPointF &);
    QRect window() const;
    void setWindow(const QRect &);
    QRect viewport() const;
    void setViewport(const QRect &);
    void setViewTransformEnabled(bool);
    bool viewTransformEnabled() const;
    void strokePath(const QPainterPath &, const QPen &);
    void fillPath(const QPainterPath &, const QBrush &);
    void drawPath(const QPainterPath &);
    void drawPoints(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawPoints(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPoints(const QPolygonF &);
    void drawPoints(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawPoints(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPoints(const QPolygon &);
    void drawLines(const QLineF *line, ...);
%MethodCode
        QLineF *lines = qtgui_inst_array<QLineF>(a0, a1, sipType_QLineF);
        
        if (lines)
        {
            sipCpp->drawLines(lines, 1 + PyTuple_GET_SIZE(a1));
            delete[] lines;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QLineF> &);
    void drawLines(const QPointF *pointPair, ...);
%MethodCode
        QPointF *pairs = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (pairs)
        {
            sipCpp->drawLines(pairs, (1 + PyTuple_GET_SIZE(a1)) / 2);
            delete[] pairs;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QPointF> &);
    void drawLines(const QLine *line, ...);
%MethodCode
        QLine *lines = qtgui_inst_array<QLine>(a0, a1, sipType_QLine);
        
        if (lines)
        {
            sipCpp->drawLines(lines, 1 + PyTuple_GET_SIZE(a1));
            delete[] lines;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QLine> &);
    void drawLines(const QPoint *pointPair, ...);
%MethodCode
        QPoint *pairs = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (pairs)
        {
            sipCpp->drawLines(pairs, (1 + PyTuple_GET_SIZE(a1)) / 2);
            delete[] pairs;
        }
        else
            sipIsErr = 1;
%End

    void drawLines(const QVector<QPoint> &);
    void drawRects(const QRectF *rect, ...);
%MethodCode
        QRectF *rects = qtgui_inst_array<QRectF>(a0, a1, sipType_QRectF);
        
        if (rects)
        {
            sipCpp->drawRects(rects, 1 + PyTuple_GET_SIZE(a1));
            delete[] rects;
        }
        else
            sipIsErr = 1;
%End

    void drawRects(const QVector<QRectF> &);
    void drawRects(const QRect *rect, ...);
%MethodCode
        QRect *rects = qtgui_inst_array<QRect>(a0, a1, sipType_QRect);
        
        if (rects)
        {
            sipCpp->drawRects(rects, 1 + PyTuple_GET_SIZE(a1));
            delete[] rects;
        }
        else
            sipIsErr = 1;
%End

    void drawRects(const QVector<QRect> &);
    void drawEllipse(const QRectF &);
    void drawEllipse(const QRect &);
    void drawPolyline(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawPolyline(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolyline(const QPolygonF &);
    void drawPolyline(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawPolyline(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolyline(const QPolygon &);
    void drawPolygon(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolygon(const QPolygonF &, Qt::FillRule fillRule = Qt::OddEvenFill);
    void drawPolygon(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawPolygon(const QPolygon &, Qt::FillRule fillRule = Qt::OddEvenFill);
    void drawConvexPolygon(const QPointF *point, ...);
%MethodCode
        QPointF *points = qtgui_inst_array<QPointF>(a0, a1, sipType_QPointF);
        
        if (points)
        {
            sipCpp->drawConvexPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawConvexPolygon(const QPolygonF &);
    void drawConvexPolygon(const QPoint *point, ...);
%MethodCode
        QPoint *points = qtgui_inst_array<QPoint>(a0, a1, sipType_QPoint);
        
        if (points)
        {
            sipCpp->drawConvexPolygon(points, 1 + PyTuple_GET_SIZE(a1));
            delete[] points;
        }
        else
            sipIsErr = 1;
%End

    void drawConvexPolygon(const QPolygon &);
    void drawArc(const QRectF &, int, int);
    void drawPie(const QRectF &, int, int);
    void drawChord(const QRectF &, int, int);
    void drawRoundRect(const QRectF &, int xRound = 25, int yRound = 25);
    void drawTiledPixmap(const QRectF &, const QPixmap &, const QPointF &pos = QPointF());
    void drawPicture(const QPointF &, const QPicture &);
    void drawPixmap(const QRectF &, const QPixmap &, const QRectF &);
    void setLayoutDirection(Qt::LayoutDirection);
    Qt::LayoutDirection layoutDirection() const;
    void drawText(const QPointF &, const QString &);
    void drawText(const QRectF &, int, const QString &, QRectF *boundingRect /Out/ = 0);
    void drawText(const QRect &, int, const QString &, QRect *boundingRect /Out/ = 0);
    void drawText(const QRectF &, const QString &, const QTextOption &option = QTextOption());
    QRectF boundingRect(const QRectF &, int, const QString &);
    QRect boundingRect(const QRect &, int, const QString &);
    QRectF boundingRect(const QRectF &, const QString &, const QTextOption &option = QTextOption());
    void fillRect(const QRectF &, const QBrush &);
    void fillRect(const QRect &, const QBrush &);
    void eraseRect(const QRectF &);
    void setRenderHint(QPainter::RenderHint, bool on = true);
    QFlags<QPainter::RenderHint> renderHints() const;
%If (Qt_4_2_0 -)
    void setRenderHints(QFlags<QPainter::RenderHint>, bool on = true);
%End
    QPaintEngine *paintEngine() const;
    static void setRedirected(const QPaintDevice *, QPaintDevice *, const QPoint &offset = QPoint());
    static QPaintDevice *redirected(const QPaintDevice *, QPoint *offset = 0);
    static void restoreRedirected(const QPaintDevice *);
    void drawLine(const QLineF &);
    void drawLine(const QLine &);
    void drawLine(int, int, int, int);
    void drawLine(const QPoint &, const QPoint &);
    void drawLine(const QPointF &, const QPointF &);
    void drawRect(const QRectF &);
    void drawRect(int, int, int, int);
    void drawRect(const QRect &);
    void drawPoint(const QPointF &);
    void drawPoint(int, int);
    void drawPoint(const QPoint &);
    void drawRoundRect(int, int, int, int, int xRound = 25, int yRound = 25);
    void drawRoundRect(const QRect &, int xRound = 25, int yRound = 25);
    void drawEllipse(int, int, int, int);
    void drawArc(const QRect &, int, int);
    void drawArc(int, int, int, int, int, int);
    void drawPie(const QRect &, int, int);
    void drawPie(int, int, int, int, int, int);
    void drawChord(const QRect &, int, int);
    void drawChord(int, int, int, int, int, int);
    void setClipRect(int, int, int, int, Qt::ClipOperation operation = Qt::ReplaceClip);
    void setClipRect(const QRect &, Qt::ClipOperation operation = Qt::ReplaceClip);
    void eraseRect(const QRect &);
    void eraseRect(int, int, int, int);
    void fillRect(int, int, int, int, const QBrush &);
    void setBrushOrigin(int, int);
    void setBrushOrigin(const QPoint &);
    void drawTiledPixmap(const QRect &, const QPixmap &, const QPoint &pos = QPoint());
    void drawTiledPixmap(int, int, int, int, const QPixmap &, int sx = 0, int sy = 0);
    void drawPixmap(const QRect &, const QPixmap &, const QRect &);
    void drawPixmap(const QPointF &, const QPixmap &);
    void drawPixmap(const QPoint &, const QPixmap &);
    void drawPixmap(const QRect &, const QPixmap &);
    void drawPixmap(int, int, const QPixmap &);
    void drawPixmap(int, int, int, int, const QPixmap &);
    void drawPixmap(int, int, int, int, const QPixmap &, int, int, int, int);
    void drawPixmap(int, int, const QPixmap &, int, int, int, int);
    void drawPixmap(const QPointF &, const QPixmap &, const QRectF &);
    void drawPixmap(const QPoint &, const QPixmap &, const QRect &);
    void drawImage(const QRectF &, const QImage &, const QRectF &, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QRect &, const QImage &, const QRect &, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QPointF &, const QImage &, const QRectF &, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QPoint &, const QImage &, const QRect &, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawImage(const QRectF &, const QImage &);
    void drawImage(const QRect &, const QImage &);
    void drawImage(const QPointF &, const QImage &);
    void drawImage(const QPoint &, const QImage &);
    void drawImage(int, int, const QImage &, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor);
    void drawText(const QPoint &, const QString &);
    void drawText(int, int, int, int, int, const QString &, QRect *boundingRect /Out/ = 0);
    void drawText(int, int, const QString &);
    QRect boundingRect(int, int, int, int, int, const QString &);
%If (Qt_4_2_0 -)
    QMatrix combinedMatrix() const;
%End
%If (Qt_4_2_0 -)
    qreal opacity() const;
%End
%If (Qt_4_2_0 -)
    void setOpacity(qreal);
%End
    void translate(qreal, qreal);
    void translate(const QPoint &);
    void setViewport(int, int, int, int);
    void setWindow(int, int, int, int);
%If (Qt_4_2_0 -)
    const QMatrix &worldMatrix() const;
%End
%If (Qt_4_2_0 -)
    void setWorldMatrix(const QMatrix &, bool combine = false);
%End
%If (Qt_4_2_0 -)
    bool worldMatrixEnabled() const;
%End
%If (Qt_4_2_0 -)
    void setWorldMatrixEnabled(bool);
%End
    void drawPicture(int, int, const QPicture &);
    void drawPicture(const QPoint &, const QPicture &);
%If (Qt_4_3_0 -)
    void setTransform(const QTransform &, bool combine = false);
%End
%If (Qt_4_3_0 -)
    const QTransform &transform() const;
%End
%If (Qt_4_3_0 -)
    const QTransform &deviceTransform() const;
%End
%If (Qt_4_3_0 -)
    void resetTransform();
%End
%If (Qt_4_3_0 -)
    void setWorldTransform(const QTransform &, bool combine = false);
%End
%If (Qt_4_3_0 -)
    const QTransform &worldTransform() const;
%End
%If (Qt_4_3_0 -)
    QTransform combinedTransform() const;
%End
%If (Qt_4_3_0 -)
    bool testRenderHint(QPainter::RenderHint) const;
%End
%If (Qt_4_4_0 -)
    void drawRoundedRect(const QRectF &, qreal, qreal, Qt::SizeMode mode = Qt::AbsoluteSize);
%End
%If (Qt_4_4_0 -)
    void drawRoundedRect(int, int, int, int, qreal, qreal, Qt::SizeMode mode = Qt::AbsoluteSize);
%End
%If (Qt_4_4_0 -)
    void drawRoundedRect(const QRect &, qreal, qreal, Qt::SizeMode mode = Qt::AbsoluteSize);
%End
%If (Qt_4_4_0 -)
    void drawEllipse(const QPointF &, qreal, qreal);
%End
%If (Qt_4_4_0 -)
    void drawEllipse(const QPoint &, int, int);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRectF &, const QColor &);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRect &, const QColor &);
%End
%If (Qt_4_5_0 -)
    void fillRect(int, int, int, int, const QColor &);
%End
%If (Qt_4_5_0 -)
    void fillRect(int, int, int, int, Qt::GlobalColor);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRect &, Qt::GlobalColor);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRectF &, Qt::GlobalColor);
%End
%If (Qt_4_5_0 -)
    void fillRect(int, int, int, int, Qt::BrushStyle);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRect &, Qt::BrushStyle);
%End
%If (Qt_4_5_0 -)
    void fillRect(const QRectF &, Qt::BrushStyle);
%End
%If (Qt_4_6_0 -)
    void beginNativePainting();
%End
%If (Qt_4_6_0 -)
    void endNativePainting();
%End
%If (Qt_4_7_0 -)

    class PixmapFragment
    {
%TypeHeaderCode
#include <qpainter.h>
%End

    public:
        qreal x;
        qreal y;
        qreal sourceLeft;
        qreal sourceTop;
        qreal width;
        qreal height;
        qreal scaleX;
        qreal scaleY;
        qreal rotation;
        qreal opacity;
        static QPainter::PixmapFragment create(const QPointF &, const QRectF &, qreal scaleX = 1, qreal scaleY = 1, qreal rotation = 0, qreal opacity = 1) /Factory/;
    };

%End
%If (Qt_4_7_0 -)

    enum PixmapFragmentHint
    {
        OpaqueHint,
    };

%End
%If (Qt_4_7_0 -)
    typedef QFlags<QPainter::PixmapFragmentHint> PixmapFragmentHints;
%End
%If (Qt_4_7_0 -)
    void drawPixmapFragments(SIP_PYLIST fragments, const QPixmap &pixmap, QFlags<QPainter::PixmapFragmentHint> hints = 0) /DocType="list-of-QPainter.PixmapFragment"/;
%MethodCode
        // Allocate temporary storage for the C++ conversions.
        SIP_SSIZE_T numFragments = PyList_GET_SIZE(a0);
        QPainter::PixmapFragment *fragments = new QPainter::PixmapFragment[numFragments];
        
        // Convert the fragments.
        for (SIP_SSIZE_T i = 0; i < numFragments; ++i)
        {
            void *cpp = sipForceConvertToType(PyList_GET_ITEM(a0, i), sipType_QPainter_PixmapFragment, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
        
            fragments[i] = *reinterpret_cast<QPainter::PixmapFragment *>(cpp);
        }
        
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->drawPixmapFragments(fragments, numFragments, *a1, *a2);
            Py_END_ALLOW_THREADS
        }
        
        delete[] fragments;
%End

%End
%If (Qt_4_7_0 -)
    void drawStaticText(const QPointF &topLeftPosition, const QStaticText &staticText);
%End
%If (Qt_4_7_0 -)
    void drawStaticText(const QPoint &p, const QStaticText &staticText);
%End
%If (Qt_4_7_0 -)
    void drawStaticText(int x, int y, const QStaticText &staticText);
%End

private:
%If (Qt_4_2_0 -)
    QPainter(const QPainter &);
%End
};

QFlags<QPainter::RenderHint> operator|(QPainter::RenderHint, QFlags<QPainter::RenderHint>);
