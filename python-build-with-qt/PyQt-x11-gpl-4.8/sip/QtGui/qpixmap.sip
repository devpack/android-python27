// qpixmap.sip generated by MetaSIP on Fri Oct 22 13:36:23 2010
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qpixmap.h>
%End

class QPixmap : QPaintDevice
{
%TypeHeaderCode
#include <qpixmap.h>
%End

public:
    QPixmap();
    QPixmap(int, int);
    QPixmap(const QSize &);
    QPixmap(const QString &, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    QPixmap(SIP_PYLIST /DocType="list-of-str"/) [(const char **xpm /DocType="list-of-str"/)];
%MethodCode
        // The Python interface is a list of strings that make up the image.
        
        const char **str = QtGui_ListToArray(a0);
        
        if (str)
        {
            sipCpp = new sipQPixmap(str);
            QtGui_DeleteArray(str);
        }
        else
            sipIsErr = 1;
%End

    QPixmap(const QPixmap &);
    QPixmap(const QVariant &variant) /NoDerived/;
%MethodCode
        sipCpp = new sipQPixmap(qVariantValue<QPixmap>(*a0));
%End

    virtual ~QPixmap();
    bool isNull() const;
    virtual int devType() const;
    int width() const;
    int height() const;
    QSize size() const;
    QRect rect() const;
    int depth() const;
    static int defaultDepth();
    void fill(const QColor &color = Qt::white);
    void fill(const QWidget *, const QPoint &);
    void fill(const QWidget *, int, int);
    QBitmap mask() const;
    void setMask(const QBitmap &);
    QPixmap alphaChannel() const;
    void setAlphaChannel(const QPixmap &);
    bool hasAlpha() const;
    bool hasAlphaChannel() const;
    QBitmap createHeuristicMask(bool clipTight = true) const;
%If (Qt_4_3_0 -)
    QBitmap createMaskFromColor(const QColor &, Qt::MaskMode) const;
%End
    QBitmap createMaskFromColor(const QColor &) const;
    static QPixmap grabWindow(WId, int x = 0, int y = 0, int width = -1, int height = -1);
    static QPixmap grabWidget(QWidget *, const QRect &);
    static QPixmap grabWidget(QWidget *, int x = 0, int y = 0, int width = -1, int height = -1);
    QPixmap scaled(int, int, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const;
    QPixmap scaled(const QSize &, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const;
    QPixmap scaledToWidth(int, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap scaledToHeight(int, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap transformed(const QMatrix &, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QMatrix trueMatrix(const QMatrix &, int, int);
    QImage toImage() const;
    static QPixmap fromImage(const QImage &, Qt::ImageConversionFlags flags = Qt::AutoColor);
%If (Qt_4_7_0 -)
    static QPixmap fromImageReader(QImageReader *imageReader, Qt::ImageConversionFlags flags = Qt::AutoColor);
%End
%If (Qt_4_7_0 -)
    bool convertFromImage(const QImage &img, Qt::ImageConversionFlags flags = Qt::AutoColor);
%End
    bool load(const QString &, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    bool loadFromData(const uchar * /Array/, uint /ArraySize/, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    bool loadFromData(const QByteArray &, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
%If (Qt_4_2_0 -)
    bool save(const QString &, const char *format = 0, int quality = -1) const;
%End
%If (- Qt_4_2_0)
    bool save(const QString &, const char *, int quality = -1) const;
%End
%If (Qt_4_2_0 -)
    bool save(QIODevice *, const char *format = 0, int quality = -1) const;
%End
%If (- Qt_4_2_0)
    bool save(QIODevice *, const char *, int quality = -1) const;
%End
%If (WS_WIN)
// Windows specific conversion functions.
enum HBitmapFormat
{
    NoAlpha,
    PremultipliedAlpha
};

HBITMAP toWinHBITMAP(QPixmap::HBitmapFormat format = QPixmap::NoAlpha) const;
static QPixmap fromWinHBITMAP(HBITMAP bitmap, QPixmap::HBitmapFormat format = QPixmap::NoAlpha);

%If (Qt_4_6_0 -)
HICON toWinHICON() const;
static QPixmap fromWinHICON(HICON icon);
%End
%End
    QPixmap copy(const QRect &rect = QRect()) const;
    int serialNumber() const;
    void detach();
%If (WS_X11)
    Qt::HANDLE x11PictureHandle() const;
%End
    bool isQBitmap() const;
%If (WS_X11)
    const QX11Info &x11Info() const;
%End
%If (WS_X11 || WS_QWS)
//    Qt::HANDLE handle() const;
%End    
    virtual QPaintEngine *paintEngine() const;

protected:
    virtual int metric(QPaintDevice::PaintDeviceMetric) const;

public:
    QPixmap copy(int, int, int, int) const;
%If (Qt_4_3_0 -)
    QPixmap transformed(const QTransform &, Qt::TransformationMode mode = Qt::FastTransformation) const;
%End
%If (Qt_4_3_0 -)
    static QTransform trueMatrix(const QTransform &, int, int);
%End
%If (Qt_4_3_0 -)
    qint64 cacheKey() const;
%End
%If (Qt_4_5_0 -)
%If (WS_X11)

    enum ShareMode
    {
        ImplicitlyShared,
        ExplicitlyShared,
    };

%End
%End
%If (Qt_4_5_0 -)
%If (WS_X11)
    static QPixmap fromX11Pixmap(Qt::HANDLE, QPixmap::ShareMode mode = QPixmap::ImplicitlyShared);
%End
%End
%If (Qt_4_6_0 -)
    void scroll(int, int, const QRect &, QRegion *exposed /Out/ = 0);
%End
%If (Qt_4_6_0 -)
    void scroll(int, int, int, int, int, int, QRegion *exposed /Out/ = 0);
%End
};

QDataStream &operator<<(QDataStream &, const QPixmap & /Constrained/);
QDataStream &operator>>(QDataStream &, QPixmap & /Constrained/);
%If (Qt_4_3_0 -)
void qSwap(QPixmap &, QPixmap &);
%End
