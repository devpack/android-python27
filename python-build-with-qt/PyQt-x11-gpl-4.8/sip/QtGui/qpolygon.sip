// qpolygon.sip generated by MetaSIP on Fri Oct 22 13:36:23 2010
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qpolygon.h>
%End

class QPolygon
{
%TypeHeaderCode
#include <qpolygon.h>
%End

%TypeCode
// Set the points of a polygon from a Python list.
static bool setPointsFromList(QPolygon *poly, PyObject *l)
{
    int *coords = new int[PyList_GET_SIZE(l)];

    for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(l); ++i)
    {
        coords[i] = SIPLong_AsLong(PyList_GET_ITEM(l, i));

        if (PyErr_Occurred() != NULL)
        {
            delete[] coords;
            return false;
        }
    }

    poly->setPoints(PyList_GET_SIZE(l) >> 1, coords);

    delete[] coords;
    return true;
}
%End

%PickleCode
    PyObject *pl = PyList_New(sipCpp->count() * 2);
    
    for (int p = 0, i = 0; i < sipCpp->count(); ++i, p += 2)
    {
        int x, y;
    
        sipCpp->point(i, &x, &y);
    
        PyList_SET_ITEM(pl, p, SIPLong_FromLong(x));
        PyList_SET_ITEM(pl, p + 1, SIPLong_FromLong(y));
    }
    
    sipRes = Py_BuildValue((char *)"(N)", pl);
%End

public:
    QPolygon();
    ~QPolygon();
    QPolygon(const QPolygon &);
    QPolygon(const QVector<QPoint> &);
    QPolygon(const QRect &, bool closed = false);
    QPolygon(int);
    QPolygon(SIP_PYLIST points /DocType="list-of-int"/) /NoDerived/;
%MethodCode
        sipCpp = new QPolygon();
        
        if (!setPointsFromList(sipCpp, a0))
        {
            delete sipCpp;
            sipCpp = 0;
            sipIsErr = 1;
        }
%End

    QPolygon(const QVariant &variant) /NoDerived/;
%MethodCode
        sipCpp = new QPolygon(qVariantValue<QPolygon>(*a0));
%End

    void translate(int, int);
    QRect boundingRect() const;
    QPoint point(int) const;
    void setPoints(SIP_PYLIST points /DocType="list-of-int"/);
%MethodCode
        if (!setPointsFromList(sipCpp, a0))
            sipIsErr = 1;
%End

    void setPoints(int firstx, int firsty, ...);
%MethodCode
        // Accept at least one pair of integer coordinates.
        int nPoints = 1 + ((PyTuple_GET_SIZE(a2) + 1) >> 1);
        
        int *points = new int[nPoints * 2];
        
        points[0] = a0;
        points[1] = a1;
        
        for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(a2); ++i)
            points[2 + i] = SIPLong_AsLong(PyTuple_GET_ITEM(a2, i));
        
        sipCpp->setPoints(nPoints, points);
        
        delete[] points;
%End

    void putPoints(int index, int firstx, int firsty, ...);
%MethodCode
        // Accept at least one pair of integer coordinates.
        int nPoints = 1 + ((PyTuple_GET_SIZE(a3) + 1) >> 1);
        
        int *points = new int[nPoints * 2];
        
        points[0] = a1;
        points[1] = a2;
        
        for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(a3); ++i)
            points[2 + i] = SIPLong_AsLong(PyTuple_GET_ITEM(a3, i));
        
        sipCpp->putPoints(a0, nPoints, points);
        
        delete[] points;
%End

    void putPoints(int, int, const QPolygon &, int from = 0);
    void setPoint(int, const QPoint &);
    void setPoint(int, int, int);
    void translate(const QPoint &);
%If (Qt_4_3_0 -)
    bool containsPoint(const QPoint &, Qt::FillRule) const;
%End
%If (Qt_4_3_0 -)
    QPolygon united(const QPolygon &) const;
%End
%If (Qt_4_3_0 -)
    QPolygon intersected(const QPolygon &) const;
%End
%If (Qt_4_3_0 -)
    QPolygon subtracted(const QPolygon &) const;
%End
%If (Qt_4_6_0 -)
    QPolygon translated(int, int) const;
%End
%If (Qt_4_6_0 -)
    QPolygon translated(const QPoint &) const;
%End
// Methods inherited from QVector<QPoint> and Python special methods.
// Keep in sync with QPolygonF and QXmlStreamAttributes.

void append(const QPoint &value);
const QPoint &at(int i) const;
void clear();
bool contains(const QPoint &value) const;
int count(const QPoint &value) const;
int count() const /__len__/;
void *data();

// Note the Qt return value is discarded as it would require handwritten code
// and seems pretty useless.
void fill(const QPoint &value, int size = -1);

QPoint &first();
int indexOf(const QPoint &value, int from = 0) const;
void insert(int i, const QPoint &value);
bool isEmpty() const;
QPoint &last();
int lastIndexOf(const QPoint &value, int from = -1) const;

// Note the Qt return type is QVector<QPoint>.
QPolygon mid(int pos, int length = -1) const;

void prepend(const QPoint &value);
void remove(int i);
void remove(int i, int count);
void replace(int i, const QPoint &value);
int size() const;
QPoint value(int i) const;
QPoint value(int i, const QPoint &defaultValue) const;
bool operator!=(const QPolygon &other) const;

// Note the Qt return type is QVector<QPoint>.
QPolygon operator+(const QPolygon &other) const;

QPolygon &operator+=(const QPolygon &other);
QPolygon &operator+=(const QPoint &value);
bool operator==(const QPolygon &other) const;

SIP_PYOBJECT operator<<(const QPoint &value);
%MethodCode
    *a0 << *a1;

    sipRes = sipArg0;
    Py_INCREF(sipRes);
%End

QPoint &operator[](int i);
%MethodCode
SIP_SSIZE_T idx = sipConvertFromSequenceIndex(a0, sipCpp->count());

if (idx < 0)
    sipIsErr = 1;
else
    sipRes = new QPoint(sipCpp->operator[]((int)idx));
%End

// Some additional Python special methods.

void __setitem__(int i, const QPoint &value);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    (*sipCpp)[a0] = *a1;
%End

void __setitem__(SIP_PYSLICE slice, const QPolygon &list);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    int vlen = a1->count();

    if (vlen != slicelength)
    {
        sipBadLengthForSlice(vlen, slicelength);
        sipIsErr = 1;
    }
    else
    {
        QVector<QPoint>::const_iterator it = a1->begin();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipCpp)[start] = *it;
            start += step;
            ++it;
        }
    }
}
%End

void __delitem__(int i);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    sipCpp->remove(a0);
%End

void __delitem__(SIP_PYSLICE slice);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
    for (i = 0; i < slicelength; ++i)
    {
        sipCpp->remove(start);
        start += step - 1;
    }
%End

QPolygon &operator[](SIP_PYSLICE slice);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    sipRes = new QPolygon();

    for (i = 0; i < slicelength; ++i)
    {
        (*sipRes) += (*sipCpp)[start];
        start += step;
    }
}
%End

int __contains__(const QPoint &value);
%MethodCode
// It looks like you can't assign QBool to int.
sipRes = bool(sipCpp->contains(*a0));
%End
};

class QPolygonF
{
%TypeHeaderCode
#include <qpolygon.h>
%End

public:
    QPolygonF();
    ~QPolygonF();
    QPolygonF(const QPolygonF &);
    QPolygonF(const QVector<QPointF> &);
    QPolygonF(const QRectF &);
    QPolygonF(const QPolygon &);
    QPolygonF(int);
    void translate(const QPointF &);
    QPolygon toPolygon() const;
    bool isClosed() const;
    QRectF boundingRect() const;
    void translate(qreal, qreal);
%If (Qt_4_3_0 -)
    bool containsPoint(const QPointF &, Qt::FillRule) const;
%End
%If (Qt_4_3_0 -)
    QPolygonF united(const QPolygonF &) const;
%End
%If (Qt_4_3_0 -)
    QPolygonF intersected(const QPolygonF &) const;
%End
%If (Qt_4_3_0 -)
    QPolygonF subtracted(const QPolygonF &) const;
%End
%If (Qt_4_6_0 -)
    QPolygonF translated(const QPointF &) const;
%End
%If (Qt_4_6_0 -)
    QPolygonF translated(qreal, qreal) const;
%End
// Methods inherited from QVector<QPointF> and Python special methods.
// Keep in sync with QPolygon and QXmlStreamAttributes.

void append(const QPointF &value);
const QPointF &at(int i) const;
void clear();
bool contains(const QPointF &value) const;
int count(const QPointF &value) const;
int count() const /__len__/;
void *data();

// Note the Qt return value is discarded as it would require handwritten code
// and seems pretty useless.
void fill(const QPointF &value, int size = -1);

QPointF &first();
int indexOf(const QPointF &value, int from = 0) const;
void insert(int i, const QPointF &value);
bool isEmpty() const;
QPointF &last();
int lastIndexOf(const QPointF &value, int from = -1) const;

// Note the Qt return type is QVector<QPointF>.
QPolygonF mid(int pos, int length = -1) const;

void prepend(const QPointF &value);
void remove(int i);
void remove(int i, int count);
void replace(int i, const QPointF &value);
int size() const;
QPointF value(int i) const;
QPointF value(int i, const QPointF &defaultValue) const;
bool operator!=(const QPolygonF &other) const;

// Note the Qt return type is QVector<QPointF>.
QPolygonF operator+(const QPolygonF &other) const;

QPolygonF &operator+=(const QPolygonF &other);
QPolygonF &operator+=(const QPointF &value);
bool operator==(const QPolygonF &other) const;

SIP_PYOBJECT operator<<(const QPointF &value);
%MethodCode
    *a0 << *a1;

    sipRes = sipArg0;
    Py_INCREF(sipRes);
%End

QPointF &operator[](int i);
%MethodCode
SIP_SSIZE_T idx = sipConvertFromSequenceIndex(a0, sipCpp->count());

if (idx < 0)
    sipIsErr = 1;
else
    sipRes = new QPointF(sipCpp->operator[]((int)idx));
%End

// Some additional Python special methods.

void __setitem__(int i, const QPointF &value);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    (*sipCpp)[a0] = *a1;
%End

void __setitem__(SIP_PYSLICE slice, const QPolygonF &list);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    int vlen = a1->count();

    if (vlen != slicelength)
    {
        sipBadLengthForSlice(vlen, slicelength);
        sipIsErr = 1;
    }
    else
    {
        QVector<QPointF>::const_iterator it = a1->begin();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipCpp)[start] = *it;
            start += step;
            ++it;
        }
    }
}
%End

void __delitem__(int i);
%MethodCode
int len;

len = sipCpp->count();

if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) < 0)
    sipIsErr = 1;
else
    sipCpp->remove(a0);
%End

void __delitem__(SIP_PYSLICE slice);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
    for (i = 0; i < slicelength; ++i)
    {
        sipCpp->remove(start);
        start += step - 1;
    }
%End

QPolygonF &operator[](SIP_PYSLICE slice);
%MethodCode
SIP_SSIZE_T len, start, stop, step, slicelength, i;

len = sipCpp->count();

if (PySlice_GetIndicesEx((PySliceObject *)a0, len, &start, &stop, &step, &slicelength) < 0)
    sipIsErr = 1;
else
{
    sipRes = new QPolygonF();

    for (i = 0; i < slicelength; ++i)
    {
        (*sipRes) += (*sipCpp)[start];
        start += step;
    }
}
%End

int __contains__(const QPointF &value);
%MethodCode
// It looks like you can't assign QBool to int.
sipRes = bool(sipCpp->contains(*a0));
%End
};

QDataStream &operator<<(QDataStream &, const QPolygonF & /Constrained/);
QDataStream &operator>>(QDataStream &, QPolygonF & /Constrained/);
%If (Qt_4_4_0 -)
QDataStream &operator<<(QDataStream &, const QPolygon & /Constrained/);
%End
%If (Qt_4_4_0 -)
QDataStream &operator>>(QDataStream &, QPolygon & /Constrained/);
%End
