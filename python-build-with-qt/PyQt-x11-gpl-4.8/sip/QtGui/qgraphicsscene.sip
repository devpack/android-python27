// qgraphicsscene.sip generated by MetaSIP on Fri Oct 22 13:36:23 2010
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_2_0 -)
%ModuleCode
#include <qgraphicsscene.h>
%End
%End

%If (Qt_4_2_0 -)

class QGraphicsScene : QObject
{
%TypeHeaderCode
#include <qgraphicsscene.h>
%End

public:
    enum ItemIndexMethod
    {
        BspTreeIndex,
        NoIndex,
    };

    QGraphicsScene(QObject *parent /TransferThis/ = 0);
%MethodCode
        // We want to track the instance.
        
        Py_BEGIN_ALLOW_THREADS
        sipCpp = new sipQGraphicsScene(a0);
        qtgui_track(sipCpp);
        Py_END_ALLOW_THREADS
%End

    QGraphicsScene(const QRectF &, QObject *parent /TransferThis/ = 0);
%MethodCode
        // We want to track the instance.
        
        Py_BEGIN_ALLOW_THREADS
        sipCpp = new sipQGraphicsScene(*a0, a1);
        qtgui_track(sipCpp);
        Py_END_ALLOW_THREADS
%End

    QGraphicsScene(qreal, qreal, qreal, qreal, QObject *parent /TransferThis/ = 0);
%MethodCode
        // We want to track the instance.
        
        Py_BEGIN_ALLOW_THREADS
        sipCpp = new sipQGraphicsScene(a0, a1, a2, a3, a4);
        qtgui_track(sipCpp);
        Py_END_ALLOW_THREADS
%End

    virtual ~QGraphicsScene();
    QRectF sceneRect() const;
    qreal width() const;
    qreal height() const;
    void setSceneRect(const QRectF &);
    void setSceneRect(qreal, qreal, qreal, qreal);
    void render(QPainter *, const QRectF &target = QRectF(), const QRectF &source = QRectF(), Qt::AspectRatioMode mode = Qt::KeepAspectRatio);
    QGraphicsScene::ItemIndexMethod itemIndexMethod() const;
    void setItemIndexMethod(QGraphicsScene::ItemIndexMethod);
    QRectF itemsBoundingRect() const;
    QList<QGraphicsItem*> items() const;
    QList<QGraphicsItem*> items(const QPointF &) const;
    QList<QGraphicsItem*> items(const QRectF &, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QList<QGraphicsItem*> items(const QPolygonF &, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QList<QGraphicsItem*> items(const QPainterPath &, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%If (Qt_4_3_0 -)
    QList<QGraphicsItem*> items(qreal, qreal, qreal, qreal, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
%End
    QList<QGraphicsItem*> collidingItems(const QGraphicsItem *, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
    QGraphicsItem *itemAt(const QPointF &) const;
    QGraphicsItem *itemAt(qreal, qreal) const;
    QList<QGraphicsItem*> selectedItems() const;
    void setSelectionArea(const QPainterPath &);
    void clearSelection();
    QGraphicsItemGroup *createItemGroup(const QList<QGraphicsItem*> & /Transfer/);
    void destroyItemGroup(QGraphicsItemGroup * /Transfer/);
    void addItem(QGraphicsItem * /Transfer/);
    QGraphicsEllipseItem *addEllipse(const QRectF &, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%If (Qt_4_3_0 -)
    QGraphicsEllipseItem *addEllipse(qreal, qreal, qreal, qreal, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%End
    QGraphicsLineItem *addLine(const QLineF &, const QPen &pen = QPen());
%If (Qt_4_3_0 -)
    QGraphicsLineItem *addLine(qreal, qreal, qreal, qreal, const QPen &pen = QPen());
%End
    QGraphicsPathItem *addPath(const QPainterPath &, const QPen &pen = QPen(), const QBrush &brush = QBrush());
    QGraphicsPixmapItem *addPixmap(const QPixmap &);
    QGraphicsPolygonItem *addPolygon(const QPolygonF &, const QPen &pen = QPen(), const QBrush &brush = QBrush());
    QGraphicsRectItem *addRect(const QRectF &, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%If (Qt_4_3_0 -)
    QGraphicsRectItem *addRect(qreal, qreal, qreal, qreal, const QPen &pen = QPen(), const QBrush &brush = QBrush());
%End
%If (Qt_4_3_0 -)
    QGraphicsSimpleTextItem *addSimpleText(const QString &, const QFont &font = QFont());
%End
    QGraphicsTextItem *addText(const QString &, const QFont &font = QFont());
    void removeItem(QGraphicsItem * /TransferBack/);
    QGraphicsItem *focusItem() const;
    void setFocusItem(QGraphicsItem *, Qt::FocusReason focusReason = Qt::OtherFocusReason);
    bool hasFocus() const;
    void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason);
    void clearFocus();
    QGraphicsItem *mouseGrabberItem() const;
    QBrush backgroundBrush() const;
    void setBackgroundBrush(const QBrush &);
    QBrush foregroundBrush() const;
    void setForegroundBrush(const QBrush &);
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;
    QList<QGraphicsView*> views() const;

public slots:
    void advance();
    void update(const QRectF &rect = QRectF());
%If (Qt_4_3_0 -)
    void invalidate(const QRectF &rect = QRectF(), QFlags<QGraphicsScene::SceneLayer> layers = QGraphicsScene::AllLayers);
%End
%If (Qt_4_4_0 -)
    void clear();
%End

signals:
    void changed(const QList<QRectF> &);
    void sceneRectChanged(const QRectF &);
%If (Qt_4_3_0 -)
    void selectionChanged();
%End

protected:
    virtual bool event(QEvent *);
    virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *);
    virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *);
    virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *);
    virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *);
    virtual void dropEvent(QGraphicsSceneDragDropEvent *);
    virtual void focusInEvent(QFocusEvent *);
    virtual void focusOutEvent(QFocusEvent *);
    virtual void helpEvent(QGraphicsSceneHelpEvent *);
    virtual void keyPressEvent(QKeyEvent *);
    virtual void keyReleaseEvent(QKeyEvent *);
    virtual void mousePressEvent(QGraphicsSceneMouseEvent *);
    virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *);
    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *);
    virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *);
    virtual void wheelEvent(QGraphicsSceneWheelEvent *);
    virtual void inputMethodEvent(QInputMethodEvent *);
    virtual void drawBackground(QPainter *, const QRectF &);
    virtual void drawForeground(QPainter *, const QRectF &);
    virtual void drawItems(QPainter *painter, SIP_PYLIST items /DocType="list-of-QGraphicsItem"/, SIP_PYLIST options /DocType="list-of-QStyleOptionGraphicsItem"/, QWidget *widget = 0) [void (QPainter *painter, int numItems, QGraphicsItem **items, const QStyleOptionGraphicsItem *options, QWidget *widget = 0)];
%MethodCode
        // PyQt takes lists as the items and options arguments.
        
        // Adjust the number items according to the actual list lengths.
        SIP_SSIZE_T numItems = PyList_GET_SIZE(a1);
        
        if (numItems > PyList_GET_SIZE(a2))
            numItems = PyList_GET_SIZE(a2);
        
        // Allocate temporary storage for the C++ conversions.
        QGraphicsItem **items = new QGraphicsItem *[numItems];
        QStyleOptionGraphicsItem *options = new QStyleOptionGraphicsItem[numItems];
        
        for (int i = 0; i < numItems; ++i)
        {
            void *cpp;
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a1, i), sipType_QGraphicsItem, NULL, SIP_NO_CONVERTORS, NULL, &sipIsErr);
            items[i] = reinterpret_cast<QGraphicsItem *>(cpp);
        
            cpp = sipForceConvertToType(PyList_GET_ITEM(a2, i), sipType_QStyleOptionGraphicsItem, NULL, SIP_NOT_NONE|SIP_NO_CONVERTORS, NULL, &sipIsErr);
            options[i] = *reinterpret_cast<QStyleOptionGraphicsItem *>(cpp);
        }
        
        if (!sipIsErr)
        {
            Py_BEGIN_ALLOW_THREADS
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            if (sipSelfWasArg)
                sipCpp->QGraphicsScene::drawItems(a0, numItems, items, options, a3);
            else
                sipCpp->drawItems(a0, numItems, items, options, a3);
        #else
            sipCpp->sipProtectVirt_drawItems(sipSelfWasArg, a0, numItems, items, options, a3);
        #endif
            Py_END_ALLOW_THREADS
        }
        
        delete[] items;
        delete[] options;
%End

%VirtualCatcherCode
        // PyQt handles the items and options arguments as lists, but keeps the
        // numItems argument.
        PyObject *items = PyList_New(a1);
        PyObject *options = PyList_New(a1);
        
        sipIsErr = (!items || !options);
        
        if (!sipIsErr)
            for (int i = 0; i < a1; ++i)
            {
                PyObject *obj;
        
                obj = sipConvertFromType(a2[i], sipType_QGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(items, i, obj);
        
                obj = sipConvertFromType(const_cast<QStyleOptionGraphicsItem *>(&a3[i]), sipType_QStyleOptionGraphicsItem, 0);
        
                if (!obj)
                {
                    sipIsErr = true;
                    break;
                }
        
                PyList_SET_ITEM(options, i, obj);
            }
        
        if (!sipIsErr)
        {
            PyObject *res = sipCallMethod(&sipIsErr, sipMethod, "DSSD", a0, sipType_QPainter, NULL, items, options, a4, sipType_QWidget, NULL);
        
            if (res)
            {
                sipParseResult(&sipIsErr, sipMethod, res, "Z");
                Py_DECREF(res);
            }
        }
        
        Py_XDECREF(items);
        Py_XDECREF(options);
%End

public:
%If (Qt_4_3_0 -)

    enum SceneLayer
    {
        ItemLayer,
        BackgroundLayer,
        ForegroundLayer,
        AllLayers,
    };

%End
%If (Qt_4_3_0 -)
    typedef QFlags<QGraphicsScene::SceneLayer> SceneLayers;
%End
%If (Qt_4_3_0 -)
    int bspTreeDepth() const;
%End
%If (Qt_4_3_0 -)
    void setBspTreeDepth(int);
%End
%If (Qt_4_3_0 -)
    QPainterPath selectionArea() const;
%End
%If (Qt_4_3_0 -)
    void setSelectionArea(const QPainterPath &, Qt::ItemSelectionMode);
%End
%If (Qt_4_3_0 -)
    void update(qreal, qreal, qreal, qreal);
%End
%If (Qt_4_3_0 -)
    void invalidate(qreal, qreal, qreal, qreal, QFlags<QGraphicsScene::SceneLayer> layers = QGraphicsScene::AllLayers);
%End
%If (Qt_4_4_0 -)
    QGraphicsProxyWidget *addWidget(QWidget * /Transfer/, Qt::WindowFlags flags = 0);
%End
%If (Qt_4_4_0 -)
    QStyle *style() const;
%End
%If (Qt_4_4_0 -)
    void setStyle(QStyle * /Transfer/);
%End
%If (Qt_4_4_0 -)
    QFont font() const;
%End
%If (Qt_4_4_0 -)
    void setFont(const QFont &);
%End
%If (Qt_4_4_0 -)
    QPalette palette() const;
%End
%If (Qt_4_4_0 -)
    void setPalette(const QPalette &);
%End
%If (Qt_4_4_0 -)
    QGraphicsWidget *activeWindow() const;
%End
%If (Qt_4_4_0 -)
    void setActiveWindow(QGraphicsWidget *);
%End

protected:
%If (Qt_4_4_0 -)
    virtual bool eventFilter(QObject *, QEvent *);
%End
%If (Qt_4_4_0 -)
    bool focusNextPrevChild(bool);
%End

public:
%If (Qt_4_5_0 -)
    bool isSortCacheEnabled() const;
%End
%If (Qt_4_5_0 -)
    void setSortCacheEnabled(bool);
%End
%If (Qt_4_5_0 -)
    void setStickyFocus(bool);
%End
%If (Qt_4_5_0 -)
    bool stickyFocus() const;
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(Qt::SortOrder) const;
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(const QPointF &, Qt::ItemSelectionMode, Qt::SortOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(const QRectF &, Qt::ItemSelectionMode, Qt::SortOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(const QPolygonF &, Qt::ItemSelectionMode, Qt::SortOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(const QPainterPath &, Qt::ItemSelectionMode, Qt::SortOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_4_6_0 -)
    QList<QGraphicsItem*> items(qreal, qreal, qreal, qreal, Qt::ItemSelectionMode, Qt::SortOrder, const QTransform &deviceTransform = QTransform()) const;
%End
%If (Qt_4_6_0 -)
    QGraphicsItem *itemAt(const QPointF &, const QTransform &) const;
%End
%If (Qt_4_6_0 -)
    QGraphicsItem *itemAt(qreal, qreal, const QTransform &) const;
%End
%If (Qt_4_6_0 -)
    void setSelectionArea(const QPainterPath &, const QTransform &);
%End
%If (Qt_4_6_0 -)
    void setSelectionArea(const QPainterPath &, Qt::ItemSelectionMode, const QTransform &);
%End
%If (Qt_4_6_0 -)
    bool isActive() const;
%End
%If (Qt_4_6_0 -)
    QGraphicsItem *activePanel() const;
%End
%If (Qt_4_6_0 -)
    void setActivePanel(QGraphicsItem *);
%End
%If (Qt_4_6_0 -)
    bool sendEvent(QGraphicsItem *, QEvent *);
%End

private:
%If (Qt_4_4_0 -)
    QGraphicsScene(const QGraphicsScene &);
%End
};

%End
%If (Qt_4_3_0 -)
QFlags<QGraphicsScene::SceneLayer> operator|(QGraphicsScene::SceneLayer, QFlags<QGraphicsScene::SceneLayer>);
%End
