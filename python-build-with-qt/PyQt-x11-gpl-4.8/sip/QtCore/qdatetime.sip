// qdatetime.sip generated by MetaSIP on Fri Oct 22 13:36:23 2010
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qdatetime.h>
%End

class QDate
{
%TypeHeaderCode
#include <qdatetime.h>
%End

%TypeCode
#include <QHash>

#if PY_VERSION_HEX >= 0x02040000
#include <datetime.h>
#endif
%End

%ConvertToTypeCode
#if PY_VERSION_HEX >= 0x02040000
    if (!PyDateTimeAPI)
        PyDateTime_IMPORT;
#endif

// Allow a Python date object whenever a QDate is expected.

if (sipIsErr == NULL)
    return (
#if PY_VERSION_HEX >= 0x02040000
            PyDate_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QDate, SIP_NO_CONVERTORS));

#if PY_VERSION_HEX >= 0x02040000
if (PyDate_Check(sipPy))
{
    *sipCppPtr = new QDate(PyDateTime_GET_YEAR(sipPy),
                           PyDateTime_GET_MONTH(sipPy),
                           PyDateTime_GET_DAY(sipPy));

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = reinterpret_cast<QDate *>(sipConvertToType(sipPy, sipType_QDate, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%PickleCode
    sipRes = Py_BuildValue((char *)"iii", sipCpp->year(), sipCpp->month(), sipCpp->day());
%End

public:
    QDate();
    QDate(int, int, int);
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        sipRes =
        #if PY_MAJOR_VERSION >= 3
            PyUnicode_FromFormat
        #else
            PyString_FromFormat
        #endif
                ("PyQt4.QtCore.QDate(%i, %i, %i)", sipCpp->year(),
                 sipCpp->month(), sipCpp->day());
%End

    long __hash__() const;
%MethodCode
        if (sipIsAPIEnabled("QDate", 2, 0))
        {
            sipRes = qHash(sipCpp->toString(Qt::ISODate));
        }
        else
        {
            // Mimic Python's default behavour.
            sipRes = _Py_HashPointer(sipSelf);
        }
%End

%If (Py_DateTime)
    SIP_PYOBJECT toPyDate() const /DocType="datetime.date"/;
%MethodCode
        if (!PyDateTimeAPI)
            PyDateTime_IMPORT;
        
        // Convert to a Python date object.
        sipRes = PyDate_FromDate(sipCpp->year(), sipCpp->month(), sipCpp->day());
%End

%End
    bool isNull() const;
    int __bool__() const;
%MethodCode
        sipRes = !sipCpp->isNull();
%End

    bool isValid() const;
    int year() const;
    int month() const;
    int day() const;
    int dayOfWeek() const;
    int dayOfYear() const;
    int daysInMonth() const;
    int daysInYear() const;
    int weekNumber(int *yearNumber = 0) const;
    static QString shortMonthName(int);
    static QString shortDayName(int);
    static QString longMonthName(int);
    static QString longDayName(int);
    QString toString(Qt::DateFormat format = Qt::TextDate) const;
    QString toString(const QString &) const;
    bool setYMD(int, int, int);
    QDate addDays(int) const;
    QDate addMonths(int) const;
    QDate addYears(int) const;
    int daysTo(const QDate &) const;
    bool operator==(const QDate &) const;
    bool operator!=(const QDate &) const;
    bool operator<(const QDate &) const;
    bool operator<=(const QDate &) const;
    bool operator>(const QDate &) const;
    bool operator>=(const QDate &) const;
    static QDate currentDate();
    static QDate fromString(const QString &, Qt::DateFormat format = Qt::TextDate);
    static QDate fromString(const QString &, const QString &);
    static bool isValid(int, int, int);
    static bool isLeapYear(int);
    static uint gregorianToJulian(int, int, int);
    static void julianToGregorian(uint, int &, int &, int &);
    static QDate fromJulianDay(int);
    int toJulianDay() const;
%If (Qt_4_2_0 -)
    bool setDate(int, int, int);
%End
%If (Qt_4_5_0 -)
    void getDate(int *, int *, int *);
%End
%If (Qt_4_5_0 -)

    enum MonthNameType
    {
        DateFormat,
        StandaloneFormat,
    };

%End
%If (Qt_4_5_0 -)
    static QString shortMonthName(int, QDate::MonthNameType);
%End
%If (Qt_4_5_0 -)
    static QString shortDayName(int, QDate::MonthNameType);
%End
%If (Qt_4_5_0 -)
    static QString longMonthName(int, QDate::MonthNameType);
%End
%If (Qt_4_5_0 -)
    static QString longDayName(int, QDate::MonthNameType);
%End
};

class QTime
{
%TypeHeaderCode
#include <qdatetime.h>
%End

%TypeCode
#include <QHash>

#if PY_VERSION_HEX >= 0x02040000
#include <datetime.h>
#endif
%End

%ConvertToTypeCode
#if PY_VERSION_HEX >= 0x02040000
    if (!PyDateTimeAPI)
        PyDateTime_IMPORT;
#endif

// Allow a Python time object whenever a QTime is expected.

if (sipIsErr == NULL)
    return (
#if PY_VERSION_HEX >= 0x02040000
            PyTime_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QTime, SIP_NO_CONVERTORS));

#if PY_VERSION_HEX >= 0x02040000
if (PyTime_Check(sipPy))
{
    *sipCppPtr = new QTime(PyDateTime_TIME_GET_HOUR(sipPy),
                           PyDateTime_TIME_GET_MINUTE(sipPy),
                           PyDateTime_TIME_GET_SECOND(sipPy),
                           PyDateTime_TIME_GET_MICROSECOND(sipPy) / 1000);

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = reinterpret_cast<QTime *>(sipConvertToType(sipPy, sipType_QTime, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%PickleCode
    sipRes = Py_BuildValue((char *)"iiii", sipCpp->hour(), sipCpp->minute(), sipCpp->second(), sipCpp->msec());
%End

public:
    QTime();
    QTime(int, int, int second = 0, int msec = 0);
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        #if PY_MAJOR_VERSION >= 3
        sipRes = PyUnicode_FromFormat("PyQt4.QtCore.QTime(%i, %i", sipCpp->hour(),
                sipCpp->minute());
        
        if (sipCpp->second() || sipCpp->msec())
        {
            qpycore_Unicode_ConcatAndDel(&sipRes,
                    PyUnicode_FromFormat(", %i", sipCpp->second()));
        
            if (sipCpp->msec())
                qpycore_Unicode_ConcatAndDel(&sipRes,
                        PyUnicode_FromFormat(", %i", sipCpp->msec()));
        }
        
        qpycore_Unicode_ConcatAndDel(&sipRes, PyUnicode_FromString(")"));
        #else
        sipRes = PyString_FromFormat("PyQt4.QtCore.QTime(%i, %i", sipCpp->hour(),
                sipCpp->minute());
        
        if (sipCpp->second() || sipCpp->msec())
        {
            PyString_ConcatAndDel(&sipRes,
                    PyString_FromFormat(", %i", sipCpp->second()));
        
            if (sipCpp->msec())
                PyString_ConcatAndDel(&sipRes,
                        PyString_FromFormat(", %i", sipCpp->msec()));
        }
        
        PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
%End

    long __hash__() const;
%MethodCode
        if (sipIsAPIEnabled("QTime", 2, 0))
        {
            sipRes = qHash(sipCpp->toString(Qt::ISODate));
        }
        else
        {
            // Mimic Python's default behavour.
            sipRes = _Py_HashPointer(sipSelf);
        }
%End

%If (Py_DateTime)
    SIP_PYOBJECT toPyTime() const /DocType="datetime.time"/;
%MethodCode
        if (!PyDateTimeAPI)
            PyDateTime_IMPORT;
        
        // Convert to a Python time object.
        sipRes = PyTime_FromTime(sipCpp->hour(), sipCpp->minute(), sipCpp->second(), sipCpp->msec() * 1000);
%End

%End
    bool isNull() const;
    int __bool__() const;
%MethodCode
        sipRes = !sipCpp->isNull();
%End

    bool isValid() const;
    int hour() const;
    int minute() const;
    int second() const;
    int msec() const;
    QString toString(Qt::DateFormat format = Qt::TextDate) const;
    QString toString(const QString &) const;
    bool setHMS(int, int, int, int msec = 0);
    QTime addSecs(int) const;
    int secsTo(const QTime &) const;
    QTime addMSecs(int) const;
    int msecsTo(const QTime &) const;
    bool operator==(const QTime &) const;
    bool operator!=(const QTime &) const;
    bool operator<(const QTime &) const;
    bool operator<=(const QTime &) const;
    bool operator>(const QTime &) const;
    bool operator>=(const QTime &) const;
    static QTime currentTime();
    static QTime fromString(const QString &, Qt::DateFormat format = Qt::TextDate);
    static QTime fromString(const QString &, const QString &);
    static bool isValid(int, int, int, int msec = 0);
    void start();
    int restart();
    int elapsed() const;
};

class QDateTime
{
%TypeHeaderCode
#include <qdatetime.h>
%End

%TypeCode
#include <QHash>

#if PY_VERSION_HEX >= 0x02040000
#include <datetime.h>
#endif
%End

%ConvertToTypeCode
#if PY_VERSION_HEX >= 0x02040000
    if (!PyDateTimeAPI)
        PyDateTime_IMPORT;
#endif

// Allow a Python datetime object whenever a QDateTime is expected.

if (sipIsErr == NULL)
    return (
#if PY_VERSION_HEX >= 0x02040000
            PyDateTime_Check(sipPy) ||
#endif
            sipCanConvertToType(sipPy, sipType_QDateTime, SIP_NO_CONVERTORS));

#if PY_VERSION_HEX >= 0x02040000
if (PyDateTime_Check(sipPy))
{
    QDate qdate(PyDateTime_GET_YEAR(sipPy),
                PyDateTime_GET_MONTH(sipPy),
                PyDateTime_GET_DAY(sipPy));

    QTime qtime(PyDateTime_DATE_GET_HOUR(sipPy),
                PyDateTime_DATE_GET_MINUTE(sipPy),
                PyDateTime_DATE_GET_SECOND(sipPy),
                PyDateTime_DATE_GET_MICROSECOND(sipPy) / 1000);

    QDateTime *qdt = new QDateTime(qdate, qtime);

    *sipCppPtr = qdt;

    return sipGetState(sipTransferObj);
}
#endif

*sipCppPtr = reinterpret_cast<QDateTime *>(sipConvertToType(sipPy, sipType_QDateTime, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
%End

%PickleCode
    QDate qd = sipCpp->date();
    QTime qt = sipCpp->time();
    
    sipRes = Py_BuildValue((char *)"iiiiiiii", qd.year(), qd.month(), qd.day(),
            qt.hour(), qt.minute(), qt.second(), qt.msec(),
            (int)sipCpp->timeSpec());
%End

public:
    QDateTime();
    QDateTime(const QDateTime &);
    explicit QDateTime(const QDate &);
    QDateTime(const QDate &, const QTime &, Qt::TimeSpec timeSpec = Qt::LocalTime);
    QDateTime(int y, int m, int d, int h, int m, int s = 0, int msec = 0, int timeSpec = 0) /NoDerived/;
%MethodCode
        // This ctor is mainly supplied to allow pickling.
        QDate qd(a0, a1, a2);
        QTime qt(a3, a4, a5, a6);
        
        sipCpp = new QDateTime(qd, qt, (Qt::TimeSpec)a7);
%End

    ~QDateTime();
    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        QDate qd = sipCpp->date();
        QTime qt = sipCpp->time();
        
        #if PY_MAJOR_VERSION >= 3
        sipRes = PyUnicode_FromFormat("PyQt4.QtCore.QDateTime(%i, %i, %i, %i, %i",
                qd.year(), qd.month(), qd.day(), qt.hour(), qt.minute());
        
        if (qt.second() || qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
        {
            qpycore_Unicode_ConcatAndDel(&sipRes,
                    PyUnicode_FromFormat(", %i", qt.second()));
        
            if (qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
            {
                qpycore_Unicode_ConcatAndDel(&sipRes, PyUnicode_FromFormat(", %i", qt.msec()));
        
                if (sipCpp->timeSpec() != Qt::LocalTime)
                    qpycore_Unicode_ConcatAndDel(&sipRes,
                            PyUnicode_FromFormat(", PyQt4.QtCore.Qt.TimeSpec(%i)",
                                    (int)sipCpp->timeSpec()));
            }
        }
        
        qpycore_Unicode_ConcatAndDel(&sipRes, PyUnicode_FromString(")"));
        #else
        sipRes = PyString_FromFormat("PyQt4.QtCore.QDateTime(%i, %i, %i, %i, %i",
                qd.year(), qd.month(), qd.day(), qt.hour(), qt.minute());
        
        if (qt.second() || qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
        {
            PyString_ConcatAndDel(&sipRes,
                    PyString_FromFormat(", %i", qt.second()));
        
            if (qt.msec() || sipCpp->timeSpec() != Qt::LocalTime)
            {
                PyString_ConcatAndDel(&sipRes, PyString_FromFormat(", %i", qt.msec()));
        
                if (sipCpp->timeSpec() != Qt::LocalTime)
                    PyString_ConcatAndDel(&sipRes,
                            PyString_FromFormat(", PyQt4.QtCore.Qt.TimeSpec(%i)",
                                    (int)sipCpp->timeSpec()));
            }
        }
        
        PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
        #endif
%End

    long __hash__() const;
%MethodCode
        if (sipIsAPIEnabled("QDateTime", 2, 0))
        {
            sipRes = qHash(sipCpp->toString(Qt::ISODate));
        }
        else
        {
            // Mimic Python's default behavour.
            sipRes = _Py_HashPointer(sipSelf);
        }
%End

%If (Py_DateTime)
    SIP_PYOBJECT toPyDateTime() const /DocType="datetime.datetime"/;
%MethodCode
        if (!PyDateTimeAPI)
            PyDateTime_IMPORT;
        
        // Convert to a Python datetime object.
        QDate qd = sipCpp->date();
        QTime qt = sipCpp->time();
        
        sipRes = PyDateTime_FromDateAndTime(qd.year(), qd.month(), qd.day(),
                                            qt.hour(), qt.minute(), qt.second(), qt.msec() * 1000);
%End

%End
    bool isNull() const;
    int __bool__() const;
%MethodCode
        sipRes = !sipCpp->isNull();
%End

    bool isValid() const;
    QDate date() const;
    QTime time() const;
    Qt::TimeSpec timeSpec() const;
    uint toTime_t() const;
    void setDate(const QDate &);
    void setTime(const QTime &);
    void setTimeSpec(Qt::TimeSpec);
    void setTime_t(uint);
    QString toString(Qt::DateFormat format = Qt::TextDate) const;
    QString toString(const QString &) const;
    QDateTime addDays(int) const;
    QDateTime addMonths(int) const;
    QDateTime addYears(int) const;
    QDateTime addSecs(int) const;
    QDateTime addMSecs(qint64) const;
    QDateTime toTimeSpec(Qt::TimeSpec) const;
    QDateTime toLocalTime() const;
    QDateTime toUTC() const;
    int daysTo(const QDateTime &) const;
    int secsTo(const QDateTime &) const;
    bool operator==(const QDateTime &) const;
    bool operator!=(const QDateTime &) const;
    bool operator<(const QDateTime &) const;
    bool operator<=(const QDateTime &) const;
    bool operator>(const QDateTime &) const;
    bool operator>=(const QDateTime &) const;
    static QDateTime currentDateTime();
    static QDateTime fromString(const QString &, Qt::DateFormat format = Qt::TextDate);
    static QDateTime fromString(const QString &, const QString &);
%If (Qt_4_2_0 -)
    static QDateTime fromTime_t(uint);
%End
%If (Qt_4_7_0 -)
    qint64 toMSecsSinceEpoch() const;
%End
%If (Qt_4_7_0 -)
    void setMSecsSinceEpoch(qint64 msecs);
%End
%If (Qt_4_7_0 -)
    qint64 msecsTo(const QDateTime &) const;
%End
%If (Qt_4_7_0 -)
    static QDateTime currentDateTimeUtc();
%End
%If (Qt_4_7_0 -)
    static QDateTime fromMSecsSinceEpoch(qint64 msecs);
%End
%If (Qt_4_7_0 -)
    static qint64 currentMSecsSinceEpoch();
%End
};

QDataStream &operator<<(QDataStream &, const QDate & /Constrained/);
QDataStream &operator>>(QDataStream &, QDate & /Constrained/);
QDataStream &operator<<(QDataStream &, const QTime & /Constrained/);
QDataStream &operator>>(QDataStream &, QTime & /Constrained/);
QDataStream &operator<<(QDataStream &, const QDateTime & /Constrained/);
QDataStream &operator>>(QDataStream &, QDateTime & /Constrained/);
