// qabstractfileengine.sip generated by MetaSIP on Fri Oct 22 13:36:23 2010
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2010 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qabstractfileengine.h>
%End

class QAbstractFileEngine /Supertype=sip.wrapper/
{
%TypeHeaderCode
#include <qabstractfileengine.h>
%End

public:
    enum FileFlag
    {
        ReadOwnerPerm,
        WriteOwnerPerm,
        ExeOwnerPerm,
        ReadUserPerm,
        WriteUserPerm,
        ExeUserPerm,
        ReadGroupPerm,
        WriteGroupPerm,
        ExeGroupPerm,
        ReadOtherPerm,
        WriteOtherPerm,
        ExeOtherPerm,
        LinkType,
        FileType,
        DirectoryType,
        HiddenFlag,
        LocalDiskFlag,
        ExistsFlag,
        RootFlag,
        PermsMask,
        TypesMask,
        FlagsMask,
        FileInfoAll,
%If (Qt_4_3_0 -)
        BundleType,
%End
%If (Qt_4_3_0 -)
        Refresh,
%End
    };

    typedef QFlags<QAbstractFileEngine::FileFlag> FileFlags;

    enum FileName
    {
        DefaultName,
        BaseName,
        PathName,
        AbsoluteName,
        AbsolutePathName,
        LinkName,
        CanonicalName,
        CanonicalPathName,
%If (Qt_4_3_0 -)
        BundleName,
%End
    };

    enum FileOwner
    {
        OwnerUser,
        OwnerGroup,
    };

    enum FileTime
    {
        CreationTime,
        ModificationTime,
        AccessTime,
    };

    virtual ~QAbstractFileEngine();
%If (Qt_4_3_0 -)
    bool atEnd() const;
%End
    virtual bool open(QFlags<QIODevice::OpenModeFlag>) /ReleaseGIL/;
    virtual bool close() /ReleaseGIL/;
    virtual bool flush() /ReleaseGIL/;
    virtual qint64 size() const;
    virtual qint64 pos() const;
    virtual bool seek(qint64) /ReleaseGIL/;
    virtual bool isSequential() const;
    virtual bool remove() /ReleaseGIL/;
    virtual bool copy(const QString &) /ReleaseGIL/;
    virtual bool rename(const QString &) /ReleaseGIL/;
    virtual bool link(const QString &) /ReleaseGIL/;
    virtual bool mkdir(const QString &, bool) const /ReleaseGIL/;
    virtual bool rmdir(const QString &, bool) const /ReleaseGIL/;
    virtual bool setSize(qint64);
    virtual bool caseSensitive() const;
    virtual bool isRelativePath() const;
    virtual QStringList entryList(QFlags<QDir::Filter>, const QStringList &) const;
    virtual QFlags<QAbstractFileEngine::FileFlag> fileFlags(QFlags<QAbstractFileEngine::FileFlag> type = FileInfoAll) const;
    virtual bool setPermissions(uint);
    virtual QString fileName(QAbstractFileEngine::FileName file = DefaultName) const;
    virtual uint ownerId(QAbstractFileEngine::FileOwner) const;
    virtual QString owner(QAbstractFileEngine::FileOwner) const;
    virtual QDateTime fileTime(QAbstractFileEngine::FileTime) const;
    virtual void setFileName(const QString &);
    virtual int handle() const;
    virtual SIP_PYOBJECT read(qint64 maxlen) /DocType="Py_v3:bytes;str",ReleaseGIL/ [qint64 (char *data, qint64 maxlen)];
%MethodCode
        // Return the data read or None if there was an error.
        if (a0 < 0)
        {
            PyErr_SetString(PyExc_ValueError, "maximum length of data to be read cannot be negative");
            sipIsErr = 1;
        }
        else
        {
            char *s = new char[a0];
            qint64 len;
        
            Py_BEGIN_ALLOW_THREADS
            len = sipSelfWasArg ? sipCpp->QAbstractFileEngine::read(s, a0)
                                : sipCpp->read(s, a0);
            Py_END_ALLOW_THREADS
        
            if (len < 0)
            {
                Py_INCREF(Py_None);
                sipRes = Py_None;
            }
            else
            {
                sipRes = SIPBytes_FromStringAndSize(s, len);
        
                if (!sipRes)
                    sipIsErr = 1;
            }
        
            delete[] s;
        }
%End

%VirtualCatcherCode
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "n", a1);
        
        if (result != NULL)
        {
            PyObject *buf;
        
            sipParseResult(&sipIsErr, sipMethod, result, "O", &buf);
        
            if (buf == Py_None)
                sipRes = -1L;
            else if (!SIPBytes_Check(buf))
            {
                sipBadCatcherResult(sipMethod);
                sipIsErr = 1;
            }
            else
            {
                memcpy(a0, SIPBytes_AS_STRING(buf), SIPBytes_GET_SIZE(buf));
                sipRes = SIPBytes_GET_SIZE(buf);
            }
        
            Py_DECREF(buf);
            Py_DECREF(result);
        }
%End

    virtual SIP_PYOBJECT readLine(qint64 maxlen) /DocType="Py_v3:bytes;str",ReleaseGIL/ [qint64 (char *data, qint64 maxlen)];
%MethodCode
        // Return the data read or None if there was an error.
        if (a0 < 0)
        {
            PyErr_SetString(PyExc_ValueError, "maximum length of data to be read cannot be negative");
            sipIsErr = 1;
        }
        else
        {
            char *s = new char[a0];
            qint64 len;
        
            Py_BEGIN_ALLOW_THREADS
            len = sipSelfWasArg ? sipCpp->QAbstractFileEngine::readLine(s, a0)
                                : sipCpp->readLine(s, a0);
            Py_END_ALLOW_THREADS
        
            if (len < 0)
            {
                Py_INCREF(Py_None);
                sipRes = Py_None;
            }
            else
            {
                sipRes = SIPBytes_FromStringAndSize(s, len);
        
                if (!sipRes)
                    sipIsErr = 1;
            }
        
            delete[] s;
        }
%End

%VirtualCatcherCode
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "n", a1);
        
        if (result != NULL)
        {
            PyObject *buf;
        
            sipParseResult(&sipIsErr, sipMethod, result, "O", &buf);
        
            if (buf == Py_None)
                sipRes = -1L;
            else if (!SIPBytes_Check(buf))
            {
                sipBadCatcherResult(sipMethod);
                sipIsErr = 1;
            }
            else
            {
                memcpy(a0, SIPBytes_AS_STRING(buf), SIPBytes_GET_SIZE(buf));
                sipRes = SIPBytes_GET_SIZE(buf);
            }
        
            Py_DECREF(buf);
            Py_DECREF(result);
        }
%End

    virtual qint64 write(const char * /Array/, qint64 /ArraySize/) /ReleaseGIL/;
    QFile::FileError error() const;
    QString errorString() const;
    static QAbstractFileEngine *create(const QString &) /Factory/;
%If (Qt_4_4_0 -)
    void *map(qint64, qint64 /ResultSize/, QFile::MemoryMapFlags) [uchar * (qint64 offset, qint64 size /ResultSize/, QFile::MemoryMapFlags flags)];
%End
%If (Qt_4_4_0 -)
    bool unmap(void *) [bool (uchar *ptr)];
%End

protected:
    QAbstractFileEngine();
    void setError(QFile::FileError, const QString &);

private:
%If (Qt_4_2_0 -)
    QAbstractFileEngine(const QAbstractFileEngine &);
%End
};

QFlags<QAbstractFileEngine::FileFlag> operator|(QAbstractFileEngine::FileFlag, QFlags<QAbstractFileEngine::FileFlag>);

class QAbstractFileEngineHandler
{
%TypeHeaderCode
#include <qabstractfileengine.h>
%End

public:
    QAbstractFileEngineHandler();
    virtual ~QAbstractFileEngineHandler();
    virtual QAbstractFileEngine *create(const QString &) const = 0 /Factory/;
};

%If (Qt_4_3_0 -)

class QAbstractFileEngineIterator
{
%TypeHeaderCode
#include <qabstractfileengine.h>
%End

public:
    QAbstractFileEngineIterator(QFlags<QDir::Filter>, const QStringList &);
    virtual ~QAbstractFileEngineIterator();
    virtual QString next() = 0;
    virtual bool hasNext() const = 0;
    QString path() const;
    QStringList nameFilters() const;
    QFlags<QDir::Filter> filters() const;
    virtual QString currentFileName() const = 0;
    virtual QFileInfo currentFileInfo() const;
    QString currentFilePath() const;

private:
    QAbstractFileEngineIterator(const QAbstractFileEngineIterator &);
};

%End
